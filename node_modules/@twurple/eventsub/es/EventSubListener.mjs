import { __decorate } from "tslib";
import { Enumerable } from '@d-fischer/shared-utils';
import { rtfm } from '@twurple/common';
import { defaultOnError, Server } from 'httpanda';
import { EventSubBase } from "./EventSubBase.mjs";
/**
 * A listener for the Twitch EventSub event distribution mechanism.
 *
 * @hideProtected
 * @inheritDoc
 */
let EventSubListener = class EventSubListener extends EventSubBase {
    /**
     * Creates a new EventSub listener.
     *
     * @param config
     *
     * @expandParams
     */
    constructor(config) {
        super(config);
        this._adapter = config.adapter;
    }
    /**
     * Starts the backing server and listens to incoming EventSub notifications.
     *
     * @param port The port to listen on. Might be overridden by the adapter you passed.
     *
     * Defaults to 443.
     */
    async listen(port) {
        var _a;
        if (this._server) {
            throw new Error('Trying to listen while already listening');
        }
        const server = this._adapter.createHttpServer();
        this._server = new Server({
            server,
            onError: async (e, req, res, next) => {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                if (e.code === 404 && !(await this._isHostDenied(req))) {
                    this._logger.warn(`Access to unknown URL/method attempted: ${req.method} ${req.url}`);
                }
                defaultOnError(e, req, res, next);
            }
        });
        // needs to be first in chain but run last, for proper logging of status
        this._server.use((req, res, next) => {
            setImmediate(() => {
                this._logger.debug(`${req.method} ${req.path} - ${res.statusCode}`);
            });
            next();
        });
        let requestPathPrefix = undefined;
        if (this._adapter.usePathPrefixInHandlers) {
            requestPathPrefix = this._adapter.pathPrefix;
            if (requestPathPrefix) {
                requestPathPrefix = `/${requestPathPrefix.replace(/^\/|\/$/g, '')}`;
            }
        }
        const healthHandler = this._createHandleHealthRequest();
        const dropLegacyHandler = this._createDropLegacyRequest();
        const requestHandler = this._createHandleRequest();
        if (requestPathPrefix) {
            this._server.post(`${requestPathPrefix}/event/:id`, requestHandler);
            this._server.post(`${requestPathPrefix}/:id`, dropLegacyHandler);
            this._server.get(`${requestPathPrefix}`, healthHandler);
        }
        else {
            this._server.post('/event/:id', requestHandler);
            this._server.post('/:id', dropLegacyHandler);
            this._server.get('/', healthHandler);
        }
        const adapterListenerPort = await this._adapter.getListenerPort();
        if (adapterListenerPort && port) {
            this._logger.warn(`Your passed port (${port}) is being ignored because the adapter has overridden it.
Listening on port ${adapterListenerPort} instead.`);
        }
        const listenerPort = (_a = adapterListenerPort !== null && adapterListenerPort !== void 0 ? adapterListenerPort : port) !== null && _a !== void 0 ? _a : 443;
        await this._server.listen(listenerPort);
        this._readyToSubscribe = true;
        this._logger.info(`Listening on port ${listenerPort}`);
        await this._resumeExistingSubscriptions();
    }
    /**
     * Stops the backing server, suspending all active subscriptions.
     */
    async unlisten() {
        if (!this._server) {
            throw new Error('Trying to unlisten while not listening');
        }
        await Promise.all([...this._subscriptions.values()].map(async (sub) => await sub.suspend()));
        await this._server.close();
        this._server = undefined;
        this._readyToSubscribe = false;
    }
    async getHostName() {
        return await this._adapter.getHostName();
    }
    async getPathPrefix() {
        return this._adapter.pathPrefix;
    }
};
__decorate([
    Enumerable(false)
], EventSubListener.prototype, "_server", void 0);
EventSubListener = __decorate([
    rtfm('eventsub', 'EventSubListener')
], EventSubListener);
export { EventSubListener };
